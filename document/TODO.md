
- [X] 打开 p.out(postscript) 文件，用coreldraw
- [X] p.out 文件是空的！debug 一下怎么回事
- [X] 全局搜索一下所有 write(19,) 语句，找到针对 p.out 的输出，进一步找到画图的数据源，根据数据源用MATLAB实现画图
- [X] 完成 plt.f 中剩余2个函数的翻译
- [ ] fun_load_fin 内部的 global 变量未声明
- [ ] fun_load_fin 的调用有问题，模仿对 fun_load_vin 的调用修改一下
- [ ] 反演是什么意思？反演与计算偏微分有什么关系？是不是把计算结果与实际观测结果对比就是反演？
- [X] 函数中改变的变量不只是`\bvar\b(\(.*\))*\s*=[^=]`，还有再调用函数的 [ ] 中的。
- [X] fun_my_plttx 中绘制反演后的走时曲线应该是每个 ray group 对应一条线，而实际上绘制的却是所有数据点在同一个数据系列，查明该 bug！
- [X] e3 测试绘制走时曲线中，时间轴的坐标刻度不对，可能原因：多减去了 xbmin, tbmin, tadj 等，源程序中减去这个是为了调整绘图的位置，而MATLAB自动调整，所以无需减去
- [ ] 横纵坐标的 range 要手动设定，不要在绘图过程中自动确定，否则可能会出现 model 图与 tx 图的横轴坐标不对应
- [X] 程序运行速度过慢，trace 部分需要重构，使用 matlab 内置的偏微分计算方法
- [ ] fID_63 找不到是怎么回事？`fun_modwr`中
- [ ] 采用 **双线性插值** `interp2` 计算任意一点的速度值(给出任意一点的坐标，根据其 4 个顶点的速度利用线性插值确定其速度。源程序采用预先计算参数的方法，相比之下如此可能会降低速度，因此暂不采用)
- [ ] 采用 **单线性插值** `interp1` 计算炮点位置(对于只指定 x 坐标未给出 z 坐标的炮点，采用线性插值法将其插入第一层的上界面)
- [ ] 采用 **一阶微分方程组数值解法** `ode45`(即 4-5 阶 Runge-Kutta 方法)解射线追踪方程组(把 theta 和 z 都看成 x 的函数，v 则是关于 x,z 的函数，是已知的。最终解得的效果是：给出任意 x 可确定 z 和 theta 的值)。在射线与界面的交点处需要应用斯奈尔定律，那么如何确定交点呢？[参考这里](https://zhidao.baidu.com/question/435858700.html)

- [X] 使用 Fortran 源程序出现错误 `1    2    3    *** error in velocity model 2 ***`。一般是读取速度模型出了问题，程序设计了两种数据精度，一是`15       format(i2,1x,10f7.2)` 二是 `15       format(i2,1x,10f8.3)` 需要切换一下。

- [X] global 变量变成传参（加快速度接近一倍）
- [X] return 语句会增加耗时？
- [ ] | 和 & 变成 || 和 &&
- [X] compile 独立版(加快速度接近一倍)
 
- [X] 测试横波模型
- [ ] 学习 MATLAB 优化工具箱
- [ ] 用优化算法实现射线搜索模式（搜索最大和最小发射角）
- [ ] 绘图前保存结果
- [X] main 界面
- [ ] 模型全局优化，遗传算法
- [X] 添加 fort.out 文件的输出
- [X] trace 部分采用 MATLAB 内置的偏微分算法
- [ ] 采用并行计算 `parfor` 来处理 trace 部分 
- [ ] 采用并行计算 `spmd` 来处理全局最优解

优点：
- 增加算法的可读性，Matlab程序进行了充分的模块化，可扩展性大大提高。
<!-- - 增加计算精度，Fortran 语言由于静态类型的限制，其对于浮点数的保存精度有限，而在 MATLAB 中则不存在此顾虑 -->
- 加入对用户友好的图形界面
- 借用 MATLAB，绘图功能增强，方便保存图像，提取图像中任意数据系列的值，放大图像查看精细的局部信息，自由调节坐标轴范围
- 绘图与计算功能分离，支持“仅计算”，“仅绘图”和“计算并绘图”三种运行方式，模型只需运行一次，便可多次绘图查看
- 借用 MATLAB 丰富的算法工具箱，更方便地完成分析任务
    + 使用 ode 工具箱计算偏微分，源程序采用 Runge-Kutta 方法，MATLAB中有对应的方法 ode45，且支持传入相对误差和绝对误差，算法内部会根据误差值自动确定计算步长。源程序中虽然也能动态确定步长，但仅仅是一种启发式算法，并不能严格保证误差在一定阈限内
    + 使用优化工具箱搜索全局最优解，实现真正的反演。源程序没有实现真正的反演，常常需要手动调节参数大小，然后正演得到结果并通过人工比对来确定结果的好坏。反演算法包含较多的参数，且估值函数相对这些参数并非光滑的，搜索最优解相当困难。在 MATLAB 中我们可以借用其优化工具箱中的遗传算法，遗传算法是一种启发式算法，非常适合求复杂估值函数的最优解

缺点：
- 运算效率降低，Fortran 作为一种专为科学计算设计的底层语言，其常规运算效率远高于 MATLAB，因此迁移到 MATLAB 后，运算速度成为最大难题。但好在 MATLAB 具有很好的可扩展性，我们可以借助丰富的手段来优化其效率：
    + 将运算矩阵化。MATLAB 以矩阵作为基本计算单元，对矩阵运算进行了非常底层的优化加速，如果能够将运算充分地矩阵化，其运算效率甚至可以超过 Fortran
    + 借用 MATLAB 并行计算工具箱。并行计算使得程序在多核心计算机上能够获得加倍的运算速度

- [X] 让 main 函数接收泊松比数组作为参数，以使用基因算法
- [X] 使用优化计算时不输出图像
- [X] 对基因算法的过程做记录，并通过图形化方式实时展示
- [X] 检查为何 e8 算例中很多修改泊松比之后 CHI 和 RMS 并无变化！应该是 tx.in 文件不对
- [X] 检查为何画 P 波时在最后一段有 S 波的虚线叠加。fun_my_pltray 中 P 波掩膜多了一位
- [X] 对 cbnd 理解错误，使用新的模型测试
- [ ] 获取初始纵波模型（固定层之后的模型），而非横波模型
- [X] 完成按块反演泊松比的程序
- [ ] 加入所有4个炮点，开始优化泊松比
- [ ] 优化过程如下：
	1. 对所有层优化，确定每层的泊松比基准；
	2. 优化第1层，以上一步获得的泊松比为基准，上下偏差20%作为基因算法的上下限。获得结果后，代入正演，查看符合情况。如果符合得很好，继续下一步。否则分块优化，仍以泊松比基准作为上下限依据，直到符合较好；
	3. 固定第1层的结果，再次对所有层进行优化，确定之下各层的泊松比基准；
	4. 优化第2层，方法同第1层；
	5. 不断重复上述步骤


- [ ] obs31 的 s3 已重新拾取并进行了替换，需要替换服务器端
- [ ] 不考虑 obs31，尝试反演
- [ ] 不考虑最后两层，尝试反演
- [ ] 只考虑前三层，尝试反演
